<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>High Fidelity Game - Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #crosshair { display: none; position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; z-index: 100; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(0, 210, 255, 0.9); box-shadow: 0 0 4px #00d2ff; }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; } 
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; } 
        #loading { background: rgba(10, 10, 10, 0.8); color: #fff; padding: 30px 60px; font-size: 22px; font-weight: 600; letter-spacing: 1px; border-bottom: 3px solid #00d2ff; pointer-events: auto; backdrop-filter: blur(15px); cursor: pointer; display: flex; flex-direction: column; align-items: center; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .spinner { width: 35px; height: 35px; border: 4px solid #333; border-top: 4px solid #00d2ff; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #hud { position: absolute; bottom: 30px; left: 30px; color: rgba(255,255,255,0.9); font-size: 14px; background: rgba(0,0,0,0.5); padding: 15px 25px; border-radius: 8px; border-left: 4px solid #00d2ff; display: block; }
        #editor-ui { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #editor-bar { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); padding: 10px 20px; border-radius: 30px; color: white; font-weight: bold; border: 1px solid #00d2ff; display: flex; gap: 20px; pointer-events: auto; }
        #editor-panel { position: absolute; top: 80px; right: 20px; width: 300px; background: rgba(20, 20, 20, 0.95); color: #ddd; padding: 15px; border-radius: 8px; pointer-events: auto; border: 1px solid #444; font-family: monospace; font-size: 12px; }
        .editor-btn { background: #333; color: white; border: 1px solid #555; padding: 5px 10px; cursor: pointer; border-radius: 4px; margin-right: 5px; }
        .editor-btn:hover { background: #555; }
        .editor-btn.active { background: #00d2ff; color: black; border-color: #00d2ff; }
        #export-area { width: 100%; height: 150px; background: #111; color: #0f0; border: 1px solid #333; margin-top: 10px; padding: 10px; font-family: monospace; font-size: 11px; resize: none; }
        b { color: #00d2ff; }
        .key { background: #333; padding: 2px 6px; border-radius: 4px; color: white; border: 1px solid #555; }
        /* --- AXIS/FPS STYLES (GLOBAL UI) --- */
        #axis-fps-global { position: fixed; top: 10px; left: 10px; z-index: 9999; pointer-events: auto; width: 230px; background: rgba(6,10,15,0.7); border: 1px solid rgba(50, 50, 50, 0.8); padding: 8px; border-radius: 8px; color: #ddd; font-family: monospace; font-size: 12px; backdrop-filter: blur(6px); box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
        #axis-fps-global label { margin-right: 8px; display: inline-flex; align-items: center; gap:6px; cursor: pointer; }
        #fps-counter { color: #00d2ff; font-weight:700; margin-left:6px; }
        #axis-fps-global .small { font-size:11px; color:#bbb; margin-top:6px; display:block; }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="loading">
            <div class="spinner"></div>
            <div>CLICK TO START</div>
        </div>
        <div id="hud">
            <b>WASD</b> Move | <b>SHIFT</b> Sprint | <b>V</b> Change Camera | <b>F9</b> EDITOR MODE
        </div>
    </div>

    <!-- --- AXIS/FPS GLOBAL UI --- -->
    <div id="axis-fps-global">
        <div style="display:flex; align-items:center; justify-content:space-between;">
            <div style="font-weight:700; color:#00d2ff">DEBUG</div>
            <div style="font-size:11px; color:#aaa">v1</div>
        </div>
        <div class="small">FPS: <span id="fps-counter">0</span></div>

        <div style="margin-top:8px;">
            <label><input type="checkbox" id="axis-x"> <span style="color:#ff4444">X</span></label>
            <label><input type="checkbox" id="axis-y"> <span style="color:#44ff44">Y</span></label>
            <label><input type="checkbox" id="axis-z"> <span style="color:#4444ff">Z</span></label>
        </div>

        <div style="margin-top:8px; display:flex; gap:6px;">
            <button id="attach-axis-btn" class="editor-btn" style="flex:1; padding:6px 8px;">Attach</button>
            <button id="show-global-axis" class="editor-btn" style="flex:1; padding:6px 8px;">Global</button>
        </div>

        <div style="margin-top:8px; display:flex; gap:6px;">
            <button id="perf-toggle" class="editor-btn" style="flex:1; padding:6px 8px;">Perf: ON</button>
            <button id="shadow-toggle" class="editor-btn" style="flex:1; padding:6px 8px;">Shadows</button>
        </div>

        <div class="small">Tip: Press <b>L</b> to toggle Perf mode.</div>
    </div>
    <!-- --- END AXIS/FPS GLOBAL UI --- -->

    <div id="editor-ui">
        <div id="editor-bar">
            <span>üõ†Ô∏è EDIT MODE</span>
            <span style="font-weight:normal; font-size:14px; margin-top:2px;">
                <span class="key">WASD</span> Fly | Aim & Click Select | <span class="key">T</span> Move <span class="key">R</span> Rotate <span class="key">Y</span> Scale
            </span>
        </div>

        <div id="editor-panel">
            <h3 style="margin-top:0; color:#00d2ff">SELECTED OBJECT</h3>
            <div id="obj-name" style="color:#fff; margin-bottom:10px;">None</div>
            <button class="editor-btn" onclick="setGizmo('translate')">Move (T)</button>
            <button class="editor-btn" onclick="setGizmo('rotate')">Rotate (R)</button>
            <button class="editor-btn" onclick="setGizmo('scale')">Scale (Y)</button>

            <hr style="border-color:#333; margin: 15px 0;">
            <button class="editor-btn" style="width:100%; background:#00d2ff; color:#000; font-weight:bold" onclick="exportData()">üíæ GENERATE CODE</button>
            <textarea id="export-area" readonly placeholder="Select object to get code..."></textarea>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js'; 
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- CONFIG ---
        const CONFIG = {
            walkSpeed: 2.0, runSpeed: 6.5, gravity: -9.8 * 2.5, jumpForce: 8.0, 
            rotSpeed: 8.0, camSmoothness: 0.1
        };

        // --- CAMERA MODES ---
        const CAMERA_MODES = [
            { name: "TPS_CLOSE", dist: 1.5, height: 1.6 },
            { name: "FPS",       dist: 0.0, height: 1.7 },
            { name: "TPS_MID",   dist: 3.0, height: 1.9 },
            { name: "TPS_FAR",   dist: 5.5, height: 2.5 }
        ];
        let currentCamIndex = 2;

        let scene, camera, renderer, composer, clock;
        let character, mixer, actions = {}, activeAction;
        let isGameReady = false;

        // Perf state (default: ON)
        // --- PERF: toggle this to reduce expensive features for low GPU ---
        let performanceMode = true;
        let shadowsEnabled = false; // will be disabled in perf mode by default
        let composerEnabled = true;
        let envMapTexture = null;
        let ssaoPass = null, bloomPass = null;

        // Editor & physics
        let isEditMode = false;
        let transformControl;
        let raycaster = new THREE.Raycaster();
        let centerPoint = new THREE.Vector2(0, 0);
        let selectedObject = null;
        let editorCameraRotation = { x: 0, y: 0 };
        let collidableMeshList = [];
        let downRay = new THREE.Raycaster();
        let forwardRay = new THREE.Raycaster();

        // Player
        const player = { velocity: new THREE.Vector3(), onGround: false, isJumping: false };
        const keys = { w: false, a: false, s: false, d: false, shift: false, space: false, q: false, e: false };

        // Camera smoothing
        const camState = { angleX: 0, angleY: Math.PI / 8, curDist: 3.0, curHeight: 1.9 };

        // PMREM generator
        let pmremGenerator = null;

        // SOUND
        let listener;
        const sounds = { walk: null, run: null, jump: null, land: null };

        // AXIS/FPS
        let axisGroup = null, axisX = null, axisY = null, axisZ = null;
        let axisAttachedToSelected = false, showGlobalAxis = false;
        let fpsCounterEl = null, _frameCount = 0, _lastFpsTime = performance.now();

        init();
        animate();

        function init() {
            // --- PERF: renderer tweaks for low GPU ---
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" }); // antialias off for perf
            // limit pixel ratio to 1 on low GPU to save VRAM / fill rate
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // may be turned off by applyPerformanceSettings()
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.physicallyCorrectLights = true;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);
            // --- end renderer tweaks ---

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0xa0cdfa, 20, 300);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);

            // LIGHTING
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.6);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            // --- PERF: reduced shadow map size for performance ---
            sunLight.shadow.mapSize.set(1024, 1024);
            sunLight.shadow.camera.left = -150; sunLight.shadow.camera.right = 150;
            sunLight.shadow.camera.top = 150; sunLight.shadow.camera.bottom = -150;
            sunLight.shadow.bias = -0.0005;
            scene.add(sunLight);

            // PMREM for HDR (may be disabled in perf mode)
            pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();

            new RGBELoader().load('hdri.hdr', function(hdrTexture) {
                try {
                    envMapTexture = pmremGenerator.fromEquirectangular(hdrTexture).texture;
                    if (!performanceMode) {
                        scene.environment = envMapTexture;
                        scene.background = envMapTexture;
                    } else {
                        // in perf mode keep simple color background
                        scene.environment = null;
                    }
                } catch (e) {
                    console.warn("HDR processing failed", e);
                }
                hdrTexture.dispose();
            }, undefined, function(err) {
                console.warn('HDRI load failed (hdri.hdr). Make sure file is present:', err);
            });

            // TRANSFORM CONTROLS
            transformControl = new TransformControls(camera, renderer.domElement);
            scene.add(transformControl);

            // axis helpers
            createAxisHelpers(5);

            // LOAD MAP
            const mapLoader = new GLTFLoader();
            mapLoader.load('map.glb', (gltf) => {
                const map = gltf.scene;
                map.name = "MyGameMap";
                map.position.set(0, -30, 0);
                map.scale.set(1.5, 1.5, 1.5);

                map.traverse((child) => {
                    if (child.isMesh) {
                        // --- PERF: avoid many shadow-casting meshes on low GPU ---
                        child.castShadow = !performanceMode && shadowsEnabled;
                        child.receiveShadow = true;
                        collidableMeshList.push(child);

                        if (child.material) {
                            child.material.metalness = 0.3;
                            child.material.roughness = performanceMode ? Math.max(0.45, child.material.roughness || 0.45) : (child.material.roughness || 0.4);
                            child.material.envMapIntensity = (child.material.envMapIntensity !== undefined) ? child.material.envMapIntensity : (performanceMode ? 0.8 : 1.0);
                            child.material.side = THREE.FrontSide;
                            child.material.needsUpdate = true;
                        }
                    }
                });
                scene.add(map);

                // --- INTERIOR LIGHTS (kept but adjusted) ---
                try {
                    const bbox = new THREE.Box3().setFromObject(map);
                    const center = bbox.getCenter(new THREE.Vector3());
                    const size = bbox.getSize(new THREE.Vector3());

                    const roomLight = new THREE.PointLight(0xffffff, performanceMode ? 1.6 : 2.5, Math.max(20, Math.max(size.x, size.z) * 1.5));
                    roomLight.position.copy(center).add(new THREE.Vector3(0, Math.max(4, size.y * 0.5), 0));
                    roomLight.castShadow = false; // keep false for perf
                    roomLight.name = "Interior_RoomLight";
                    scene.add(roomLight);

                    const ambientLight = new THREE.AmbientLight(0xffffff, performanceMode ? 0.45 : 0.55);
                    ambientLight.name = "Interior_Ambient";
                    scene.add(ambientLight);

                    const windowLight1 = new THREE.SpotLight(0xffffff, performanceMode ? 1.0 : 2.0, Math.max(20, size.length()), Math.PI / 6, 0.4, 1);
                    windowLight1.position.copy(center).add(new THREE.Vector3(size.x * 0.5 + 1, Math.max(6, size.y * 0.6), 0));
                    windowLight1.target.position.copy(center);
                    windowLight1.castShadow = false;
                    scene.add(windowLight1);
                    scene.add(windowLight1.target);

                    const windowLight2 = new THREE.SpotLight(0xffffff, performanceMode ? 0.8 : 1.5, Math.max(20, size.length()), Math.PI / 6, 0.5, 1);
                    windowLight2.position.copy(center).add(new THREE.Vector3(-size.x * 0.5 - 1, Math.max(6, size.y * 0.6), 0));
                    windowLight2.target.position.copy(center);
                    windowLight2.castShadow = false;
                    scene.add(windowLight2);
                    scene.add(windowLight2.target);
                } catch (e) {
                    console.warn("Interior lights placement failed:", e);
                }

                // scale axis helpers relative to map size
                try {
                    const bbox2 = new THREE.Box3().setFromObject(map);
                    const size2 = bbox2.getSize(new THREE.Vector3());
                    const biggest = Math.max(size2.x, size2.y, size2.z);
                    if (axisGroup) {
                        const scalar = Math.max(1, biggest / 5);
                        axisGroup.scale.setScalar(scalar);
                    }
                } catch (e) {}
            });

            // postprocessing setup
            setupPostProcessing();

            // SOUND
            setupAudio();

            setupInputs();
            loadAssets();

            window.setGizmo = (mode) => transformControl.setMode(mode);
            window.exportData = generateCode;

            fpsCounterEl = document.getElementById('fps-counter');
            bindAxisUI();

            // apply initial performance settings
            applyPerformanceSettings(performanceMode);
        }

        async function loadAssets() {
            const loader = new FBXLoader();
            try {
                character = await loader.loadAsync('character.fbx');
                character.name = "PlayerCharacter";
                character.position.set(0, 5, 0);

                const box = new THREE.Box3().setFromObject(character);
                const size = box.getSize(new THREE.Vector3());
                if (size.y > 0) character.scale.setScalar(1.75 / size.y);

                character.traverse(obj => {
                    if (obj.isMesh) {
                        // --- PERF: reduce expensive shading for character when performanceMode ON ---
                        obj.castShadow = !performanceMode && shadowsEnabled;
                        obj.receiveShadow = true;
                        if (obj.material) {
                            if (obj.material.envMapIntensity === undefined) obj.material.envMapIntensity = performanceMode ? 0.9 : 1.5;
                            if (obj.material.roughness === undefined) obj.material.roughness = performanceMode ? 0.6 : 0.45;
                            if (obj.material.metalness === undefined) obj.material.metalness = 0.0;
                            obj.material.needsUpdate = true;
                        }
                    }
                });
                scene.add(character);

                mixer = new THREE.AnimationMixer(character);
                const loadAnim = async (name, file) => {
                    try {
                        const obj = await loader.loadAsync(file);
                        const action = mixer.clipAction(obj.animations[0]);
                        actions[name] = action;
                        if (name === 'jump') { action.setLoop(THREE.LoopOnce); action.clampWhenFinished = true; }
                    } catch (e) {}
                };

                await Promise.all([
                    loadAnim('idle', 'idle.fbx'), loadAnim('walk', 'walk.fbx'),
                    loadAnim('run', 'run.fbx'), loadAnim('jump', 'jump.fbx')
                ]);

                if (actions['idle']) { activeAction = actions['idle']; activeAction.play(); }
                mixer.addEventListener('finished', (e) => { if (e.action === actions['jump']) player.isJumping = false; });
                document.getElementById('loading').style.display = 'none';
                isGameReady = true;

            } catch (err) { console.error(err); }
        }

        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
            ssaoPass.kernelRadius = 16; ssaoPass.minDistance = 0.005; ssaoPass.maxDistance = 0.1;
            composer.addPass(ssaoPass);

            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.85);
            bloomPass.threshold = 0.75; bloomPass.strength = performanceMode ? 0.2 : 0.4; bloomPass.radius = 0.2;
            composer.addPass(bloomPass);

            composer.addPass(new OutputPass());
        }

        function applyPerformanceSettings(enablePerf) {
            performanceMode = !!enablePerf;

            // renderer pixel ratio
            renderer.setPixelRatio(performanceMode ? 1 : Math.min(window.devicePixelRatio || 1, 2));

            // shadows
            shadowsEnabled = !performanceMode; // if perf mode ON, shadows disabled by default
            renderer.shadowMap.enabled = !performanceMode && shadowsEnabled;

            // composer
            composerEnabled = !performanceMode; // disable heavy postprocessing in perf mode

            // environment
            if (performanceMode) {
                // remove heavy env map
                scene.environment = null;
                // keep plain color background to save memory
                scene.background = new THREE.Color(0x87CEEB);
                if (ssaoPass) ssaoPass.enabled = false;
                if (bloomPass) bloomPass.enabled = false;
            } else {
                // restore env map if present
                if (envMapTexture) {
                    scene.environment = envMapTexture;
                    scene.background = envMapTexture;
                }
                if (ssaoPass) ssaoPass.enabled = true;
                if (bloomPass) bloomPass.enabled = true;
            }

            // update visible shadows and castShadow flags on existing scene meshes
            scene.traverse((obj) => {
                if (obj.isMesh) {
                    try {
                        obj.castShadow = !performanceMode && shadowsEnabled;
                        obj.receiveShadow = true;
                    } catch (e) {}
                }
            });

            // reduce some expensive composer params if perf mode
            if (bloomPass) bloomPass.strength = performanceMode ? 0.2 : 0.4;

            // update UI
            const perfBtn = document.getElementById('perf-toggle');
            if (perfBtn) perfBtn.textContent = `Perf: ${performanceMode ? 'ON' : 'OFF'}`;
            const shadowBtn = document.getElementById('shadow-toggle');
            if (shadowBtn) shadowBtn.textContent = `Shadows: ${(!performanceMode && shadowsEnabled) ? 'ON' : 'OFF'}`;
        }

        function toggleShadows() {
            shadowsEnabled = !shadowsEnabled;
            // respect performanceMode: only allow shadows if performanceMode is false
            if (performanceMode) shadowsEnabled = false;
            renderer.shadowMap.enabled = !performanceMode && shadowsEnabled;
            scene.traverse((obj) => { if (obj.isMesh) obj.castShadow = !performanceMode && shadowsEnabled; });
            const shadowBtn = document.getElementById('shadow-toggle');
            if (shadowBtn) shadowBtn.textContent = `Shadows: ${(!performanceMode && shadowsEnabled) ? 'ON' : 'OFF'}`;
        }

        function setupAudio() {
            listener = new THREE.AudioListener();
            camera.add(listener);
            const audioLoader = new THREE.AudioLoader();
            function loadSound(name, file, loop = false, volume = 1.0) {
                const sound = new THREE.Audio(listener);
                audioLoader.load(file, buffer => { sound.setBuffer(buffer); sound.setLoop(loop); sound.setVolume(volume); sounds[name] = sound; }, undefined, () => console.warn('Missing sound:', file));
            }
            loadSound('walk', 'walk.mp3', true, 0.4);
            loadSound('run', 'run.mp3', true, 0.7);
            loadSound('jump', 'jump.mp3', false, 1.0);
            loadSound('land', 'land.mp3', false, 0.9);
        }

        function createAxisHelpers(baseLength = 5) {
            axisGroup = new THREE.Group();
            const geomX = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(baseLength,0,0)]);
            axisX = new THREE.Line(geomX, new THREE.LineBasicMaterial({ color: 0xff4444 }));
            axisX.name = "Axis_X";
            const geomY = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,baseLength,0)]);
            axisY = new THREE.Line(geomY, new THREE.LineBasicMaterial({ color: 0x44ff44 }));
            axisY.name = "Axis_Y";
            const geomZ = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,baseLength)]);
            axisZ = new THREE.Line(geomZ, new THREE.LineBasicMaterial({ color: 0x4444ff }));
            axisZ.name = "Axis_Z";
            axisX.visible = axisY.visible = axisZ.visible = false;
            axisGroup.add(axisX); axisGroup.add(axisY); axisGroup.add(axisZ);
            axisGroup.visible = false; axisGroup.name = "Axis_Group";
            scene.add(axisGroup);
        }

        function setAxisVisibility(x, y, z) {
            if (!axisGroup) return;
            axisX.visible = !!x; axisY.visible = !!y; axisZ.visible = !!z;
            axisGroup.visible = (axisX.visible || axisY.visible || axisZ.visible) || showGlobalAxis;
        }

        function bindAxisUI() {
            const axX = document.getElementById('axis-x');
            const axY = document.getElementById('axis-y');
            const axZ = document.getElementById('axis-z');
            const attachBtn = document.getElementById('attach-axis-btn');
            const globalBtn = document.getElementById('show-global-axis');
            const perfBtn = document.getElementById('perf-toggle');
            const shadowBtn = document.getElementById('shadow-toggle');

            axX.addEventListener('change', () => setAxisVisibility(axX.checked, axY.checked, axZ.checked));
            axY.addEventListener('change', () => setAxisVisibility(axX.checked, axY.checked, axZ.checked));
            axZ.addEventListener('change', () => setAxisVisibility(axX.checked, axY.checked, axZ.checked));

            attachBtn.addEventListener('click', () => {
                axisAttachedToSelected = !axisAttachedToSelected;
                attachBtn.textContent = axisAttachedToSelected ? 'Attached' : 'Attach';
                if (axisAttachedToSelected && selectedObject) {
                    axisGroup.position.copy(selectedObject.getWorldPosition(new THREE.Vector3()));
                    axisGroup.quaternion.copy(selectedObject.getWorldQuaternion(new THREE.Quaternion()));
                }
            });

            globalBtn.addEventListener('click', () => {
                showGlobalAxis = !showGlobalAxis;
                globalBtn.textContent = showGlobalAxis ? 'Global On' : 'Global';
                axisGroup.visible = showGlobalAxis || axisX.visible || axisY.visible || axisZ.visible;
            });

            perfBtn.addEventListener('click', () => {
                applyPerformanceSettings(!performanceMode);
            });

            shadowBtn.addEventListener('click', () => {
                toggleShadows();
            });
        }

        function setupInputs() {
            document.addEventListener('click', () => {
                if (listener && listener.context && listener.context.state === 'suspended') listener.context.resume();
            });

            document.addEventListener('keydown', e => {
                const map = { KeyW:'w', KeyA:'a', KeyS:'s', KeyD:'d', ShiftLeft:'shift', Space:'space', KeyQ:'q', KeyE:'e' };
                if (map[e.code]) keys[map[e.code]] = true;
                if (e.code === 'KeyV') currentCamIndex = (currentCamIndex + 1) % CAMERA_MODES.length;
                if (e.code === 'F9') toggleEditMode();
                if (e.code === 'KeyL') applyPerformanceSettings(!performanceMode); // quick toggle
                if (e.code === 'KeyP') toggleShadows(); // optional
                if (isEditMode) {
                    if (e.code === 'KeyT') transformControl.setMode('translate');
                    if (e.code === 'KeyR') transformControl.setMode('rotate');
                    if (e.code === 'KeyY') transformControl.setMode('scale');
                }
            });

            document.addEventListener('keyup', e => {
                const map = { KeyW:'w', KeyA:'a', KeyS:'s', KeyD:'d', ShiftLeft:'shift', Space:'space', KeyQ:'q', KeyE:'e' };
                if (map[e.code]) keys[map[e.code]] = false;
            });

            document.addEventListener('mousemove', e => {
                if (document.pointerLockElement === document.body) {
                    const sensitivity = 0.002;
                    if (isEditMode) {
                        editorCameraRotation.y -= e.movementX * sensitivity;
                        editorCameraRotation.x -= e.movementY * sensitivity;
                        editorCameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, editorCameraRotation.x));
                        camera.rotation.order = "YXZ";
                        camera.rotation.y = editorCameraRotation.y;
                        camera.rotation.x = editorCameraRotation.x;
                    } else {
                        camState.angleX -= e.movementX * sensitivity;
                        camState.angleY -= e.movementY * sensitivity;
                        camState.angleY = Math.max(0.1, Math.min(Math.PI / 2.2, camState.angleY));
                    }
                }
            });

            document.addEventListener('mousedown', (e) => {
                if (isEditMode) {
                    if (e.target.closest('#editor-panel')) return;
                    if (document.pointerLockElement !== document.body) { document.body.requestPointerLock(); return; }
                    raycaster.setFromCamera(centerPoint, camera);
                    const intersects = raycaster.intersectObjects(scene.children, true);
                    if (intersects.length > 0) {
                        let target = intersects[0].object;
                        while (target.parent && target.parent.type !== 'Scene') {
                            if (target.name === "MyGameMap" || target.name === "PlayerCharacter") break;
                            target = target.parent;
                        }
                        if (target.type !== 'LineSegments' && !target.isTransformControls) selectObject(target);
                    } else {
                        transformControl.detach();
                        selectedObject = null;
                        document.getElementById('obj-name').innerText = "None";
                    }
                } else {
                    document.body.requestPointerLock();
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if (composer) composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function toggleEditMode() {
            isEditMode = !isEditMode;
            const ui = document.getElementById('editor-ui');
            const hud = document.getElementById('hud');
            const crosshair = document.getElementById('crosshair');
            if (isEditMode) {
                ui.style.display = 'block'; hud.style.display = 'none'; crosshair.style.display = 'block';
                const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                editorCameraRotation.y = euler.y; editorCameraRotation.x = euler.x;
                if (character) character.visible = true;
            } else {
                ui.style.display = 'none'; hud.style.display = 'block'; crosshair.style.display = 'none';
                transformControl.detach(); selectedObject = null;
            }
        }

        function selectObject(obj) {
            selectedObject = obj;
            transformControl.attach(obj);
            document.getElementById('obj-name').innerText = obj.name || "Unnamed Mesh";
            if (axisAttachedToSelected && axisGroup && selectedObject) {
                axisGroup.position.copy(selectedObject.getWorldPosition(new THREE.Vector3()));
                axisGroup.quaternion.copy(selectedObject.getWorldQuaternion(new THREE.Quaternion()));
                axisGroup.visible = axisX.visible || axisY.visible || axisZ.visible || showGlobalAxis;
            }
        }

        function generateCode() {
            if (!selectedObject) { document.getElementById('export-area').value = "// No object selected"; return; }
            const p = selectedObject.position; const r = selectedObject.rotation; const s = selectedObject.scale;
            const code = `${selectedObject.name}.position.set(${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)});\n` +
                         `${selectedObject.name}.rotation.set(${r.x.toFixed(2)}, ${r.y.toFixed(2)}, ${r.z.toFixed(2)});\n` +
                         `${selectedObject.name}.scale.set(${s.x.toFixed(2)}, ${s.y.toFixed(2)}, ${s.z.toFixed(2)});`;
            document.getElementById('export-area').value = code;
        }

        // Physics & movement (same logic, only sound & shadows controlled by perf)
        function updatePhysics(dt) {
            if (!character || isEditMode) return;
            const isRunning = keys.shift;
            const speed = isRunning ? CONFIG.runSpeed : CONFIG.walkSpeed;
            const forward = new THREE.Vector3(-Math.sin(camState.angleX), 0, -Math.cos(camState.angleX));
            const right = new THREE.Vector3(Math.cos(camState.angleX), 0, -Math.sin(camState.angleX));
            let moveDir = new THREE.Vector3(0,0,0);
            if (keys.w) moveDir.add(forward); if (keys.s) moveDir.sub(forward);
            if (keys.d) moveDir.add(right); if (keys.a) moveDir.sub(right);
            const isMoving = moveDir.lengthSq() > 0;

            // movement sounds (unchanged)
            if (player.onGround && !player.isJumping) {
                if (isMoving) {
                    if (isRunning) {
                        if (sounds.walk && sounds.walk.isPlaying) sounds.walk.stop();
                        if (sounds.run && !sounds.run.isPlaying) sounds.run.play();
                    } else {
                        if (sounds.run && sounds.run.isPlaying) sounds.run.stop();
                        if (sounds.walk && !sounds.walk.isPlaying) sounds.walk.play();
                    }
                } else {
                    if (sounds.walk && sounds.walk.isPlaying) sounds.walk.stop();
                    if (sounds.run && sounds.run.isPlaying) sounds.run.stop();
                }
            } else {
                if (sounds.walk && sounds.walk.isPlaying) sounds.walk.stop();
                if (sounds.run && sounds.run.isPlaying) sounds.run.stop();
            }

            let isBlocked = false;
            if (moveDir.lengthSq() > 0) {
                moveDir.normalize();
                const rayOrigin = character.position.clone(); rayOrigin.y += 1.0;
                forwardRay.set(rayOrigin, moveDir);
                const hits = forwardRay.intersectObjects(collidableMeshList, true);
                if (hits.length > 0 && hits[0].distance < 0.5) isBlocked = true;
            }

            if (moveDir.lengthSq() > 0 && !isBlocked) {
                character.position.addScaledVector(moveDir, speed * dt);
                const targetRot = Math.atan2(moveDir.x, moveDir.z);
                let rotDiff = targetRot - character.rotation.y;
                while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                character.rotation.y += rotDiff * CONFIG.rotSpeed * dt;
                if (!player.isJumping && player.onGround) fadeToAction(isRunning ? 'run' : 'walk', 0.2);
            } else {
                if (!player.isJumping && player.onGround) fadeToAction('idle', 0.2);
            }

            if (keys.space && player.onGround && !player.isJumping) {
                player.velocity.y = CONFIG.jumpForce; player.onGround = false; player.isJumping = true;
                if (sounds.jump) { if (sounds.jump.isPlaying) sounds.jump.stop(); sounds.jump.play(); }
                fadeToAction('jump', 0.1);
            }
            player.velocity.y += CONFIG.gravity * dt;
            character.position.y += player.velocity.y * dt;

            const downOrigin = character.position.clone(); downOrigin.y += 2.0;
            downRay.set(downOrigin, new THREE.Vector3(0, -1, 0));
            const intersects = downRay.intersectObjects(collidableMeshList, true);
            if (intersects.length > 0) {
                const hit = intersects[0];
                const groundHeight = hit.point.y;
                const distToFloor = hit.distance;
                if (distToFloor <= 2.2 && player.velocity.y <= 0) {
                    if (!player.onGround) {
                        if (sounds.land) { if (sounds.land.isPlaying) sounds.land.stop(); sounds.land.play(); }
                    }
                    character.position.y = groundHeight;
                    player.velocity.y = 0;
                    player.onGround = true;
                } else if (distToFloor > 2.2) {
                    player.onGround = false;
                }
            } else {
                player.onGround = false;
                if (character.position.y < -50) character.position.set(0, 10, 0);
            }
        }

        function fadeToAction(name, duration) {
            if (!actions[name] || activeAction === actions[name]) return;
            const prev = activeAction;
            activeAction = actions[name];
            if (prev) prev.fadeOut(duration);
            activeAction.reset().fadeIn(duration).play();
        }

        function updateGameCamera() {
            if (!character) return;
            const target = CAMERA_MODES[currentCamIndex];
            camState.curDist = THREE.MathUtils.lerp(camState.curDist, target.dist, 0.1);
            camState.curHeight = THREE.MathUtils.lerp(camState.curHeight, target.height, 0.1);
            if (camState.curDist < 0.2) character.visible = false; else character.visible = true;
            const offsetX = Math.sin(camState.angleX) * camState.curDist * Math.cos(camState.angleY);
            const offsetZ = Math.cos(camState.angleX) * camState.curDist * Math.cos(camState.angleY);
            const offsetY = camState.curDist * Math.sin(camState.angleY);
            const targetPos = new THREE.Vector3(character.position.x + offsetX, character.position.y + camState.curHeight + offsetY, character.position.z + offsetZ);
            camera.position.copy(targetPos);
            const lookAtHeight = (currentCamIndex === 1) ? 1.7 : 1.5;
            camera.lookAt(character.position.x, character.position.y + lookAtHeight, character.position.z);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!isGameReady) return;
            const dt = Math.min(clock.getDelta(), 0.1);
            if (mixer) mixer.update(dt);

            // update fps
            updateFps();

            if (isEditMode) updateEditorCamera(dt); else { updatePhysics(dt); updateGameCamera(); }

            if (axisAttachedToSelected && axisGroup && selectedObject) {
                axisGroup.position.copy(selectedObject.getWorldPosition(new THREE.Vector3()));
                axisGroup.quaternion.copy(selectedObject.getWorldQuaternion(new THREE.Quaternion()));
                axisGroup.visible = axisX.visible || axisY.visible || axisZ.visible || showGlobalAxis;
            }

            // --- PERF: use composer only if enabled ---
            if (composer && composerEnabled && !performanceMode) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        function updateFps() {
            _frameCount++;
            const now = performance.now();
            const elapsed = (now - _lastFpsTime) / 1000;
            if (elapsed >= 0.5) {
                const fps = Math.round((_frameCount / elapsed));
                if (fpsCounterEl) fpsCounterEl.textContent = fps;
                _frameCount = 0;
                _lastFpsTime = now;
            }
        }
    </script>
</body>
</html>
